Estruturas de dados para o algoritmo de Path Constrained Network Flow:

Algoritmo de busca em profundidade (backtracking/força bruta)

OK - Lista de adjacências (em cada elemento, adicionar atributo de capacidade e fluxo passado)
OK - Vetor V indicando se determinado nó já foi visitado no caminho atual
OK - Vetor nei com quantidades de vizinhos que cada nó possui.
OK - Lista encadeada L para guardar o caminho percorrido
OK - Inteiro para anotar maior capacidade do caminho atual
OK - Pilha p para a busca de caminhos (em profundidade)

------

INÍCIO
OK Define fluxo total R.
OK Define aresta a (dois vértices extremos)
OK Declara variável r que armazena soma de fluxo em cada caminho
OK Define threshold de pilha vazia = PV_MAX
OK Define contador de pilha vazia PV = 0
Enquanto r<R:
	Se PV > PV_MAX:
		Encerra o loop (significa que a pilha esvaziou PV_MAX vezes durante as buscas em profundidade. Possivelmente os caminhos já estão bastante cheios.
	Fluxo f do caminho atual inicia como 0
	[1] Inicializa Pilha com vizinhos de S: p[X,Y...]
	Inicializa vetor V com elemento S = 1 e restante igual a zero
	Libera lista L
	Inicializa caminho L apenas com elemento S
	VARIÁVEL DE CONTROLE = 0
	Enquanto não visita um dos extremos da aresta a:
		Se pilha p vazia, encerra e inicia novo caminho (break). Incrementa PV++
		Se nó atual == T, encerra e inicia novo caminho (break). ADICIONAR VARIÁVEL DE CONTROLE = 1 AQUI.
		Verifica se aresta do último elemento de L para o vizinho no topo da pilha tem alguma capacidade disponível. Atualiza fluxo máximo f do caminho (atenção aos sinais) e atualiza nó em V e L.
			[3] Se atualizou f, desempilha o topo. Após isso, pega todos os caminhos vizinhos do novo nó que não estejam constando como percorrido em V e adiciona no topo de p.
			CONDIÇÃO DE PARADA AO ALCANÇAR UM DOS EXTREMOS DA ARESTA a
		Se não houver nenhuma passagem disponível (capacidade atual disponível < f), desempilha. Remove o último elemento de L caso terminem os vizinhos do elemento atual (IMPORTANTE CONTABILIZAR OS VIZINHOS A CADA REMOÇÃO NA PILHA!) (continue)

	Se nó atual é um dos extremos de a:
		Próximo nó deve ser obrigatoriamente o outro extremo de a.
		Se não for possível passar fluxo algum pela aresta a, inicia novo caminho (continue).
		[2] Se for possível, atualiza f, V e L, desempilha p e atualiza o topo da pilha com os vizinhos do outro extremo que não estejam em V.

		Enquanto não visita T:
			Se pilha p vazia, encerra e inicia novo caminho (break). Incrementa PV++
			Verifica se aresta do último elemento de L para o vizinho no topo da pilha tem alguma capacidade disponível. Atualiza fluxo máximo f do caminho (atenção aos sinais) e atualiza nó em V e L.
				CONDIÇÃO DE PARADA AO ALCANÇAR T
				[3] Se atualizou f, desempilha o topo. Após isso, pega todos os caminhos vizinhos do novo nó que não estejam constando como percorrido em V e adiciona no topo de p.
			Se não houver nenhuma passagem disponível (capacidade atual disponível < f), desempilha. Remove o último elemento de L caso terminem os vizinhos do elemento atual (IMPORTANTE CONTABILIZAR OS VIZINHOS A CADA REMOÇÃO NA PILHA!) (continue)

*****PAREI AQUI*****

	Se caminho L inicia em S e termina em T, e VARIÁVEL DE CONTROLE == 0: #significa que foi de s a t passando por a
		Acumula fluxo f em r
		Atualiza capacidades das arestas do grafo na lista de adjacências
		Zera vetor V
		Zera fluxo f
		Libera elementos da lista L

Verifica se r >= R:
	Se positivo a resposta é que sim, é possível passar fluxo mínimo R por caminhos restritos a aresta a.
	Se negativo, a resposta é que não, não é possível passar mínimo R por caminhos restritos a aresta a.

-----
OBS:
O critério de parada é definido pelo limiar PV_MAX. O esvaziamento repetido da pilha de execução da busca em profundidade é um indício de que não há mais caminhos disponíveis.
Podemos adicionar outro critério de parada por tempo, se necessário. Ex: execute por, no máximo, X minutos.

//Variante gulosa (com backtracking na busca)
// [1] Inicializa Pilha com vizinhos de S: p[X,Y...] em ordem decrescente de capacidade disponível.
// [2] Se for possível, atualiza f, V e L e o topo da pilha com os vizinhos do outro extremo em ordem decrescente de capacidade disponível.
// [3] Se atualizou f, desempilha o topo. Após isso, pega todos os caminhos vizinhos do novo nó que não estejam constando como percorrido em V e adiciona no topo de p (em ordem decrescente de capacidade disponível).
-----

Instância de Exemplo:

Nós
S -> 1[0/12;+] -> 2[0/5;+]
1 -> S[0/12;-] -> 2[0/10;+] -> T[0/8;+]
2 -> S[0/5;-] -> 1[0/10;-] -> T[0/1;+] -> 3[0/3;+]
3 -> 2[0/10;-] -> 1[0/12;+] -> T[0/2;+]
T -> 1[0/8;-] -> 2[0/1;-] -> 3[0/2;-]

OBS: nessa instância a aresta entre 3->1 nunca é percorrida pelo algoritmo. Se desenhar fica mais claro o porquê.